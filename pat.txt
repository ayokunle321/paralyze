#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// Test 1: Simple safe loop - should be parallelizable
void test_simple_safe() {
    int a[100], b[100], c[100];
    
    for (int i = 0; i < 100; i++) {
        c[i] = a[i] + b[i];  // No dependencies between iterations
    }
}

// Test 2: Loop-carried dependency - unsafe
void test_loop_carried_dependency() {
    int arr[100];
    
    for (int i = 1; i < 100; i++) {
        arr[i] = arr[i-1] + 2;  // arr[i] depends on arr[i-1]
    }
}

// Test 3: Scalar variable dependency - unsafe
void test_scalar_dependency() {
    int data[50];
    int sum = 0;
    
    for (int j = 0; j < 50; j++) {
        sum += data[j];  // sum has read-after-write dependency
        data[j] = sum;
    }
}

// Test 4: Pointer operations - unsafe
void test_pointer_operations() {
    int *ptr = malloc(100 * sizeof(int));
    int *base = ptr;
    
    for (int k = 0; k < 100; k++) {
        *ptr = k;      // Pointer dereference
        ptr++;         // Pointer arithmetic
    }
    
    free(base);
}

// Test 5: Function calls with side effects - unsafe
void test_function_calls() {
    int values[80];
    
    for (int m = 0; m < 80; m++) {
        values[m] = rand();        // rand() has side effects
        printf("%d\n", values[m]); // printf has side effects
    }
}

// Test 6: Safe math functions - potentially safe
void test_math_functions() {
    double input[60];
    double output[60];
    
    for (int n = 0; n < 60; n++) {
        output[n] = sin(input[n]) + cos(input[n]);  // Pure math functions
    }
}

// Test 7: Complex array indexing - unsafe
void test_complex_indexing() {
    int matrix[10][10];
    int indices[100];
    
    for (int i = 0; i < 100; i++) {
        int row = indices[i] % 10;
        int col = (i * 3) % 10;
        matrix[row][col] = i;  // Complex indexing pattern
    }
}

// Test 8: Cross-iteration conflicts
void test_cross_iteration() {
    int buffer[200];
    
    for (int i = 2; i < 198; i++) {
        buffer[i] = buffer[i-2] + buffer[i+1];  // Multiple offset conflicts
    }
}

// Test 9: Nested loops with different safety
void test_nested_loops() {
    int data[20][20];
    
    // Outer loop should be safe, inner has dependency
    for (int i = 0; i < 20; i++) {
        int temp = 0;
        for (int j = 1; j < 20; j++) {
            temp += data[i][j-1];    // Inner loop has dependency
            data[i][j] = temp;
        }
    }
}

// Test 10: Pointer aliasing potential
void test_pointer_aliasing() {
    int array[150];
    int *ptr1 = &array[0];
    int *ptr2 = &array[50];
    
    for (int i = 0; i < 50; i++) {
        *ptr1 = i;           // Could alias with ptr2
        *(ptr2 + i) = i * 2; // Potential aliasing conflict
        ptr1++;
    }
}

// Test 11: Write-only pattern - safe
void test_write_only() {
    int results[300];
    
    for (int i = 0; i < 300; i++) {
        results[i] = i * i * i;  // Only writing, no reads
    }
}

// Test 12: Reduction with local variable - mixed safety
void test_reduction_local() {
    int source[100];
    int total = 0;
    
    for (int i = 0; i < 100; i++) {
        int local = source[i] * 2;  // Local variable - safe
        total += local;             // Reduction - dependency
    }
}

int main() {
    test_simple_safe();
    test_loop_carried_dependency();
    test_scalar_dependency();
    test_pointer_operations();
    test_function_calls();
    test_math_functions();
    test_complex_indexing();
    test_cross_iteration();
    test_nested_loops();
    test_pointer_aliasing();
    test_write_only();
    test_reduction_local();
    
    return 0;
}#include <stdio.h>
#include <math.h>

// Test 1: Simple parallel for candidate - should get high confidence
void test_simple_parallel() {
    int a[1000], b[1000], c[1000];
    
    for (int i = 0; i < 1000; i++) {
        c[i] = a[i] + b[i];  // Simple, independent operations
    }
}

// Test 2: SIMD candidate - should get parallel for simd pragma
void test_simd_candidate() {
    double data[500];
    double results[500];
    
    for (int j = 0; j < 500; j++) {
        results[j] = data[j] * data[j] + sin(data[j]);  // Arithmetic + math function
    }
}

// Test 3: Complex but safe - should get medium confidence
void test_complex_safe() {
    float matrix[100][100];
    float output[100][100];
    int temp;
    
    for (int i = 0; i < 100; i++) {
        temp = i * 2;  // Private variable
        for (int j = 0; j < 100; j++) {
            output[i][j] = matrix[i][j] + temp;
        }
    }
}

// Test 4: Unsafe - should not generate pragma
void test_unsafe_loop() {
    int arr[50];
    
    for (int k = 1; k < 50; k++) {
        arr[k] = arr[k-1] + k;  // Loop-carried dependency
    }
}

// Test 5: Function calls - should get lower confidence or no pragma
void test_with_function_calls() {
    int values[80];
    
    for (int m = 0; m < 80; m++) {
        values[m] = m;
        printf("Value: %d\n", values[m]);  // Side effect
    }
}

// Test 6: Hot loop with many operations - should get high confidence
void test_hot_computation() {
    double input[2000];
    double output[2000];
    
    for (int n = 0; n < 2000; n++) {
        double temp = input[n];
        temp = temp * temp;
        temp = temp + (temp * 0.5);
        temp = sqrt(temp);
        output[n] = temp;  // Many arithmetic operations
    }
}

int main() {
    test_simple_parallel();
    test_simd_candidate();
    test_complex_safe();
    test_unsafe_loop();
    test_with_function_calls();
    test_hot_computation();
    
    return 0;
}// Quick validation tests for dependency analysis

// Should be SAFE
void safe_example() {
    int a[10], b[10];
    for (int i = 0; i < 10; i++) {
        b[i] = a[i] * 2;
    }
}

// Should be UNSAFE - loop carried dependency
void unsafe_example() {
    int arr[10];
    for (int i = 1; i < 10; i++) {
        arr[i] = arr[i-1] + 1;
    }
}

// Should be UNSAFE - function call
void function_call_example() {
    int data[5];
    for (int i = 0; i < 5; i++) {
        data[i] = rand();
    }
}#!/bin/bash
echo "=== Comprehensive Dependency Analysis Test Suite ==="
echo
cd ../build
echo "Running analysis on dependency_analysis.c..."
echo
./statik ../tests/dependency_analysis.c
echo ""
echo "=========================================="
echo "Expected Results Summary:"
echo "=========================================="
echo "SAFE TO PARALLELIZE:"
echo "- test_simple_safe: independent array operations"
echo "- test_write_only: only writing to results array"
echo "- test_math_functions: pure mathematical functions"
echo ""
echo "HAS DEPENDENCIES (UNSAFE):"
echo "- test_loop_carried_dependency: arr[i] depends on arr[i-1]"
echo "- test_scalar_dependency: sum variable read+write"
echo "- test_pointer_operations: pointer arithmetic and dereference"
echo "- test_function_calls: rand() and printf() side effects"
echo "- test_complex_indexing: complex matrix indexing"
echo "- test_cross_iteration: buffer[i-2] and buffer[i+1] conflicts"
echo "- test_nested_loops: inner loop has dependency"
echo "- test_pointer_aliasing: potential ptr1/ptr2 aliasing"
echo "- test_reduction_local: total variable dependency"
echo ""
echo "Notes:"
echo "- Nested loops: outer loop analysis depends on inner loop safety"
echo "- Function calls: math functions may be marked potentially safe"
echo "- Complex indexing: conservative analysis assumes unsafe"
echo "- Cross-iteration: detects offset-based conflicts"#!/bin/bash
echo "=== Testing OpenMP Pragma Generation ==="
echo
cd ../build
echo "Running pragma generation analysis on pragma_generation.c..."
echo
./statik ../tests/pragma_generation.c
echo ""
echo "=========================================="
echo "Expected Results:"
echo "=========================================="
echo "SHOULD GENERATE PRAGMAS:"
echo "- test_simple_parallel: #pragma omp parallel for (HIGH confidence)"
echo "- test_simd_candidate: #pragma omp parallel for simd (HIGH confidence)"
echo "- test_complex_safe: #pragma omp parallel for (MEDIUM confidence)"
echo "- test_hot_computation: #pragma omp parallel for simd (VERY HIGH confidence)"
echo ""
echo "SHOULD NOT GENERATE PRAGMAS:"
echo "- test_unsafe_loop: loop-carried dependency detected"
echo "- test_with_function_calls: side effects from printf()"
echo ""
echo "CONFIDENCE EXPECTATIONS:"
echo "- Simple array operations: High confidence"
echo "- Math-heavy loops: Very high confidence" 
echo "- Complex but safe patterns: Medium confidence"
echo "- Loops with side effects: No pragma or low confidence"#!/bin/bash

echo "=== Testing Variable Usage Pattern Detection ==="
echo

cd ../build

echo "Running analysis on variable_patterns.c..."
./statik ../tests/variable_patterns.c

echo ""
echo "Expected results:"
echo "- test_independent_iterations: SAFE TO PARALLELIZE"
echo "- test_loop_carried_dependency: HAS DEPENDENCIES" 
echo "- test_reduction_pattern: HAS DEPENDENCIES (sum variable)"
echo "- test_write_only: SAFE TO PARALLELIZE"
echo "- test_complex_safe: SAFE TO PARALLELIZE (temp is local)"
echo "- test_nested_loops: outer loop SAFE TO PARALLELIZE"
echo "- test_function_calls: HAS DEPENDENCIES (function calls)"// Very basic test cases for debugging

void basic_safe_loop() {
    int a[10];
    int b[10];
    
    for (int i = 0; i < 10; i++) {
        b[i] = a[i] + 1;  // Should be safe
    }
}

void basic_unsafe_loop() {
    int arr[10];
    
    for (int i = 1; i < 10; i++) {
        arr[i] = arr[i-1];  // Clear dependency
    }
}

void induction_var_test() {
    int data[100];
    
    for (int counter = 0; counter < 100; counter++) {
        data[counter] = counter * 3;  // counter should be marked as induction var
    }
}#include <stdio.h>

int main() {
    int i, j;
    int arr[100];
    int sum = 0;
    
    // Simple for loop
    for (i = 0; i < 100; i++) {
        arr[i] = i * 2;
    }
    
    // Nested for loops
    for (i = 0; i < 10; i++) {
        for (j = 0; j < 10; j++) {
            sum += i + j;
        }
    }
    
    // While loop
    i = 0;
    while (i < 50) {
        sum += arr[i];
        i++;
    }
    
    // Do-while loop
    j = 10;
    do {
        sum += j;
        j--;
    } while (j > 0);
    
    return sum;
}

void helper_function() {
    int k;
    
    // Loop in another function
    for (k = 0; k < 5; k++) {
        printf("Helper: %d\n", k);
    }
}#!/bin/bash

echo "Testing loop detection..."

cd ../build

echo "=== Testing simple_loops.c ==="
./statik ../tests/simple_loops.c

echo ""
echo "Expected: 5 loops total (2 for, 1 while, 1 do-while, 1 for in helper)"#include <stdio.h>

// Test case 1: Simple parallelizable loop (independent iterations)
void test_independent_iterations() {
    int arr[100];
    int result[100];
    
    // This should be marked as safe to parallelize
    for (int i = 0; i < 100; i++) {
        result[i] = arr[i] * 2 + 5;  // No dependencies between iterations
    }
}

// Test case 2: Loop-carried dependency (not parallelizable)
void test_loop_carried_dependency() {
    int arr[100];
    
    // This has a loop-carried dependency - NOT safe to parallelize
    for (int i = 1; i < 100; i++) {
        arr[i] = arr[i-1] + arr[i];  // arr[i] depends on arr[i-1] from previous iteration
    }
}

// Test case 3: Reduction pattern (could be parallelized with special handling)
void test_reduction_pattern() {
    int arr[100];
    int sum = 0;
    
    // Sum reduction - has dependency on 'sum' but could be parallelized
    for (int i = 0; i < 100; i++) {
        sum += arr[i];  // 'sum' is read and written each iteration
    }
}

// Test case 4: Write-only arrays (safe to parallelize)
void test_write_only() {
    int output[100];
    
    for (int i = 0; i < 100; i++) {
        output[i] = i * i;  // Only writing to output[i], no reads
    }
}

// Test case 5: Complex but safe pattern
void test_complex_safe() {
    int a[100], b[100], c[100];
    int temp;
    
    for (int j = 0; j < 100; j++) {
        temp = a[j] + b[j];      // temp is loop-local
        c[j] = temp * 2;         // Only accessing c[j], not other elements
    }
}

// Test case 6: Nested loops with different characteristics
void test_nested_loops() {
    int matrix[10][10];
    int result[10][10];
    
    // Outer loop should be parallelizable
    for (int i = 0; i < 10; i++) {
        // Inner loop accesses different rows
        for (int j = 0; j < 10; j++) {
            result[i][j] = matrix[i][j] + matrix[i][j] * 2;
        }
    }
}

// Test case 7: Function calls (should be marked unsafe)
void helper_function(int x) {
    printf("Value: %d\n", x);
}

void test_function_calls() {
    int arr[50];
    
    for (int k = 0; k < 50; k++) {
        arr[k] = k;
        helper_function(arr[k]);  // Function call makes this unsafe
    }
}

int main() {
    test_independent_iterations();
    test_loop_carried_dependency();
    test_reduction_pattern();
    test_write_only();
    test_complex_safe();
    test_nested_loops();
    test_function_calls();
    
    return 0;
}